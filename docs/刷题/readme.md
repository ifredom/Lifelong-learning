# leetcode

> 目前算法不用再考虑空间，主要考虑时间

## [时间复杂度](https://zhuanlan.zhihu.com/p/50479555)

> 我们想要知道一个算法的「时间复杂度」，很多人首先想到的的方法就是把这个算法程序运行一遍，那么它所消耗的时间就自然而然知道了。

> 这种方式可以吗？当然可以，不过它也有很多弊端。
> 这种方式非常容易受运行环境的影响，在性能高的机器上跑出来的结果与在性能低的机器上跑的结果相差会很大。而且对测试时使用的数据规模也有很大关系。再者，并我们在写算法的时候，还没有办法完整的去运行呢。

> 因此，另一种更为通用的方法就出来了：`「 大 O 符号表示法 」`，即 `T(n) = O(f(n))`,全称 **算法的渐进时间复杂度**

```js
for (i = 1; i <= n; ++i) {
  j = i;
  j++;
}
```

我们继续看上面的例子，假设每行代码的执行时间都是一样的，我们用 1 颗粒时间 来表示，那么这个例子的第一行耗时是 1 个颗粒时间，第二行的执行时间是 n 个颗粒时间，第三行的执行时间也是 n 个颗粒时间（第五行是符号，暂时忽略），那么总时间就是 1 颗粒时间 + n 颗粒时间 + n 颗粒时间 ，即 (1+2n)个颗粒时间，即： T(n) = (1+2n)\*颗粒时间，从这个结果可以看出，这个算法的耗时是随着 n 的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) = O(n)

为什么可以这么去简化呢，因为大 O 符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。

所以上面的例子中，如果 n 无限大的时候，T(n) = time(1+2n)中的常量 1 就没有意义了，倍数 2 也意义不大。因此直接简化为 T(n) = O(n) 就可以了。

常见的时间复杂度量级有：

- 常数阶 O(1)
- 对数阶 O(logN)
- 线性阶 O(n)
- 线性对数阶 O(nlogN)
- 平方阶 O(n²)
- 立方阶 O(n³)
- K 次方阶 O(n^k)
- 指数阶(2^n)

## 空间复杂度

> 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。
