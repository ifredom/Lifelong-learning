# redis

Redis，英文全称是Remote Dictionary Server（远程字典服务），是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API

## 图形化界面管理工具：AnotherRedisManager

异常1：显示Stream On Error: NOAUTH Authentication required. （不要填写用户名）


## 数据类型


- string  
	- set key value,get key value
	- 应用场景：共享session、分布式锁，计数器、限流
- hash    
	- hset key value,hget key value
	- 应用场景：缓存用户信息
- list   
	- lpush key val1 val2 val3 左插入
	- rpush key val1 val2 val3 右插入
	- lset key index newValue   在指定下标处设置新值
	- linsert key before/after privot value 在键值key中得值为privot得某一项值前/后插入数据value
	- lindex key index 获取指定键值，下标为index得值
	- lrange key startIndex endIndex 获取指定下标范围得键值得数据（lrange k1 0,-1）,-1表示结尾
	- 应用场景：有限集合，消息队列
- set 
	- sadd key value,smembers key
	- 应用场景：用户标签，随机数抽奖，社交需求
- zset

## [缓存穿透](https://juejin.cn/post/7002011542145204261)

>> 通俗点说，读请求访问时，缓存和数据库都没有某个值，这样就会导致每次对这个值的查询请求都会穿透到数据库，这就是缓存穿透。

流程：
- 读请求-查询redis数据库
	- Y - 返回redis中查询到得数据
	- N - 继续查询磁盘数据库-如果有，更新缓存-返回数据.
	如果无，返回空数据。
如何避免缓存穿透呢？ 一般有三种方法。

1.如果是非法请求，我们在API入口，对参数进行校验，过滤非法值。
2.如果查询数据库为空，我们可以给缓存设置个空值，或者默认值。但是如有有写请求进来的话，需要更新缓存哈，以保证缓存一致性，同时，最后给缓存设置适当的过期时间。（业务上比较常用，简单有效）
3.使用布隆过滤器快速判断数据是否存在。即一个查询请求过来时，先通过布隆过滤器判断值是否存在，存在才继续往下查。

## 缓存雪崩

缓存雪崩： 指缓存中数据大批量到过期时间，而查询数据量巨大，请求都直接访问数据库，引起数据库压力过大甚至down机。
缓存雪奔一般是由于大量数据同时过期造成的，对于这个原因，可通过均匀设置过期时间解决，即让过期时间相对离散一点。如采用一个较大固定值+一个较小的随机值，5小时+0到1800秒酱紫。
Redis 故障宕机也可能引起缓存雪奔。这就需要构造Redis高可用集群啦。


## 缓存击穿问题

缓存击穿： 指热点key在某个时间点过期的时候，而恰好在这个时间点对这个Key有大量的并发请求过来，从而大量的请求打到db。
缓存击穿看着有点像，其实它两区别是，缓存雪奔是指数据库压力过大甚至down机，缓存击穿只是大量并发请求到了DB数据库层面。可以认为击穿是缓存雪奔的一个子集吧。有些文章认为它俩区别，是区别在于击穿针对某一热点key缓存，雪奔则是很多key。
解决方案就有两种：

1.使用互斥锁方案。缓存失效时，不是立即去加载db数据，而是先使用某些带成功返回的原子操作命令，如(Redis的setnx）去操作，成功的时候，再去加载db数据库数据和设置缓存。否则就去重试获取缓存。
2. “永不过期”，是指没有设置过期时间，但是热点数据快要过期时，异步线程去更新和设置过期时间。


## Redis 的持久化机制
- RDB 
- AOF