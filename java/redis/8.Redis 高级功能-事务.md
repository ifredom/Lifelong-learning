# 8.Redis 高级功能-事务

> [Redis 事务中文文档](https://www.redis.com.cn/redis-transaction.html)

Redis 事务可以将其理解为一个`执行脚本文件`，里面含有批量化的 redis 操作指令，可以批量执行。在 redis 事务中的指令，任何一条操作失败，并不会导致事务中止，ye 也不会导致回滚，这是与 Mysql 事务区别的地方，等于不存在 ACID 中的原子性和一致性。

> Tips：进入 redis 服务 -- **安装目录/redis-cli**

## 为什么会出现 redis 事务功能

比如，我们有这样一个的流程：

- 用户 A 买了一件商品，
- 商家资金增加 100
- 商家仓库库存，商品减少 1
- 物流系统，添加一个订单

这个购物流程是固定的。如果没有事务，那么需要执行三条 redis 语句来将数据库中的数据进行改动。
这样岂不是很麻烦，事务此时就有用了用武之地，它可以将多条语句进行打包，组装成一个箱子。

## 如何操作事务？

一个`执行脚本文件`要运行，总得知道什么时候打开和什么时候关闭，这就叫`操作事务`，也就是对这个箱子进行的操作。
而 redis 提供了 3 个指令来操作事务：

- multi 组装事务
- exec 执行事务
- discard 停止事务
- watch 监听事务

## redis 整个事务流程是怎么样运行的？

事务是由一条条 redis 语句组成的箱子

```bash
1. get name
2. set age 18
3. delete sex
```

而 multi 就是将这一组语句按照顺序摆放，然后打包成箱子，在 redis 中是这样得

```bash
127.0.0.1:6379> set testname ifredom
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set age 18
QUEUED
127.0.0.1:6379> delete sex
QUEUED
```

此时 `multi` 已经将这两条 Redis 操作指令进行了装箱打包。

接下来执行 `exec` ，则立刻打包完成,贴上封条。然后执行刚刚打包完成的事务（箱子）中得语句

```bash
127.0.0.1:6379> set testname ifredom
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set age 18
QUEUED
127.0.0.1:6379> delete sex
QUEUED
127.0.0.1:6379> exec
1) (integer) 18
1) (integer) 0
```

在事务的执行过程中，你很有可能输入错误的 redis 操作语句对吧，有可能在 exec 执行前出错，也有可能在 exec 执行后出错，错误还分几种种类，
总结起来此时有可能出现这几种情况：

- 当你开启了事务 `multi`，却没有执行 `exec`,那么事务不会关闭
- 当你开启了事务，输入了错误的 `redis` 语句，即使接下来执行了 `exec`，那么事务也不会执行，并且`本次事务会自动关闭`
- 当你开启了事务，输入的 `redis` 语句全部正确，接下来执行了 `exec`，那么自然能执行成功，并且`本次事务会自动关闭`
- 当你开启了事务，再次输入了 `multi`，会返回给你一个错误提示，此时`本次事务不会关闭`，一切照旧
- 当你关闭了事务，输入了错误的 `redis` 语句，`不会影响事务`，毕竟都上一波操作已经完成了不是。

## 事务冲突的情况

在上面，我们都是在一个 redis 服务中操作本机的 redis 数据库。
然而还有一种情况，如果现在打开多个窗口，分别执行 redis-cli 进入 redis 服务，每个窗口都开启事务，也去操作 redis 数据库呢？此时会发生事务冲突

- 第一个窗口，开启事务。用户 A 买了一件商品，商家资金增加 300，
- 第二个窗口，开启事务。用户 B 买了一件商品，商家资金增加 200，
- 第三个窗口，开启事务。用户 C 买了一件商品，如果商家资金超过 300，那么商品打折商家资金增加 100，如果商家资金不足 300，那么商品原价商家资金增加 150

此时由于我们不可能随视知道资金有多少，所以不能确定什么时候给用户打折，十分影响销量。

此时如何解决事务冲突？

采用`乐观锁：获取数据时，认为数据没有被加锁，认为没有被修改`机制解决。

> 如何如何使用 Redis 来执行乐观锁的操作？

Redis 使用 WATCH 命令来决定事务是继续执行还是回滚，需要在 `MULTI` 之前使用 `WATCH` 来监控某些键值对，然后使用`MULTI`命令来开启事务。

在事务开始前用 WATCH 监控 k1，之后修改 k1 为 11，说明事务开始前 k1 值被改变。接下来 MULTI 开启事务，修改 k1 值为 12，k2 为 22，执行 EXEC，返回 nil。
如果按照事务中的操作语句`set k1 12`来看，k1 的值按理应该是 12 才对，但是由于 watch 了 k1 的原因，执行事务回滚，所以事务中的所有语句都回滚了；
查看下 k1、k2 的值，可以发现都没有被事务中的命令所改变。

```bash
127.0.0.1:6379> set k1 v1
OK
127.0.0.1:6379> set k2 v2
OK
127.0.0.1:6379> WATCH k1
OK
127.0.0.1:6379> set k1 11
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set k1 12
QUEUED
127.0.0.1:6379> set k2 22
QUEUED
127.0.0.1:6379> EXEC
(nil)
127.0.0.1:6379> get k1
"11"
127.0.0.1:6379> get k2
"v2"
127.0.0.1:6379>
```

### 商品秒杀场景

java-example 中 common-redis 有示例代码。

事务冲突测试工具： redis db 工具
